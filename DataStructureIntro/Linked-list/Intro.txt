All about linked list

## ğŸ”— **Linked List: Complete Explanation**  

A **Linked List** is a linear data structure where elements (nodes) are stored in **non-contiguous** memory locations. Each node contains:  
- **Data** (the actual value stored)  
- **Pointer (next)** (a reference to the next node)  

Unlike arrays, linked lists are **dynamic** in size and provide efficient insertions/deletions.

---

# ğŸš€ **1. Why Use Linked Lists?**
| Feature          | Array | Linked List |
|-----------------|-------|-------------|
| **Memory Allocation** | Contiguous (fixed size) | Non-contiguous (dynamic size) |
| **Insertion/Deletion** | Costly (O(n) for shifting) | Efficient (O(1) if inserting at head) |
| **Access Time** | O(1) (direct indexing) | O(n) (sequential search required) |
| **Memory Waste** | Wastes memory if oversized | Uses memory dynamically |

### **When to Use a Linked List?**
âœ… When you need **fast insertions and deletions**.  
âœ… When you **donâ€™t know the size** beforehand (dynamic memory).  
âœ… When continuous memory allocation is not available.  

### **When NOT to Use Linked List?**
âŒ If **random access** (O(1) indexing) is needed, use an **Array**.  
âŒ If **searching is the primary operation**, use a **Hash Table** (O(1) lookup).  

---

# ğŸ”¥ **2. Types of Linked Lists**
### **1ï¸âƒ£ Singly Linked List**
- Each node has **one pointer** (next) to the next node.
- Traversal is **one-directional**.

ğŸ“Œ **Example Structure:**
```
HEAD â†’ [10 | next] â†’ [20 | next] â†’ [30 | next] â†’ NULL
```

ğŸ“Œ **Basic Operations:**
- **Insertion** (O(1) at head, O(n) elsewhere)
- **Deletion** (O(1) at head, O(n) elsewhere)
- **Search** (O(n))

---

### **2ï¸âƒ£ Doubly Linked List (DLL)**
- Each node has **two pointers**:  
  1ï¸âƒ£ `next` (points to next node)  
  2ï¸âƒ£ `prev` (points to previous node)  
- **Two-directional traversal** is possible.

ğŸ“Œ **Example Structure:**
```
NULL â† [10 | prev | next] â†â†’ [20 | prev | next] â†â†’ [30 | prev | next] â†’ NULL
```

ğŸ“Œ **Advantages Over Singly Linked List**
âœ… **Faster Deletion (O(1))** (since `prev` pointer is available).  
âœ… **Traversal in both directions**.  
âœ… **More memory usage (O(n) extra for `prev` pointers)**.  

---

### **3ï¸âƒ£ Circular Linked List**
- **Last node points to the first node**, forming a **circle**.
- Can be **singly or doubly linked**.
- Used in **round-robin scheduling**, buffer management.

ğŸ“Œ **Example (Singly Circular Linked List)**:
```
[10 | next] â†’ [20 | next] â†’ [30 | next] â†» (points back to head)
```

---

# ğŸ›  **3. Linked List Operations (With Code)**
## **1ï¸âƒ£ Insert at Beginning (Head)**
- **O(1) Time Complexity**  
```javascript
prepend(value) {
    const newNode = { value: value, next: this.head };
    this.head = newNode;
    this.length++;
}
```

ğŸ“Œ **Why is it O(1)?**  
- We **don't need to shift elements** (unlike arrays).  
- Just **update head** to the new node.

---

## **2ï¸âƒ£ Insert at End (Tail)**
- **O(1) Time Complexity (if tail pointer exists)**
```javascript
append(value) {
    const newNode = { value: value, next: null };
    this.tail.next = newNode;
    this.tail = newNode;
    this.length++;
}
```

ğŸ“Œ **Why is it O(1)?**  
- We **directly update tail** instead of traversing.

---

## **3ï¸âƒ£ Insert at Any Position**
- **O(n) Time Complexity**  
```javascript
insert(index, value) {
    if (index < 0 || index > this.length) return;
    let newNode = { value: value, next: null };
    let currentNode = this.head;
    for (let i = 0; i < index - 1; i++) {
        currentNode = currentNode.next;
    }
    newNode.next = currentNode.next;
    currentNode.next = newNode;
    this.length++;
}
```

ğŸ“Œ **Why is it O(n)?**  
- We need to **traverse** the list to `index - 1` before inserting.

---

## **4ï¸âƒ£ Delete a Node**
- **O(n) (traversal needed), O(1) (at head)**  
```javascript
remove(index) {
    if (index < 0 || index >= this.length) return;
    let currentNode = this.head;
    if (index === 0) {
        this.head = this.head.next;
        this.length--;
        return;
    }
    let previousNode = null;
    for (let i = 0; i < index; i++) {
        previousNode = currentNode;
        currentNode = currentNode.next;
    }
    previousNode.next = currentNode.next;
    this.length--;
}
```

ğŸ“Œ **Why is deleting at the head O(1)?**  
- We just **move the head** to the next node.

ğŸ“Œ **Why is deleting in the middle O(n)?**  
- **Traversal required** to reach `index - 1`.

---

# ğŸ”¥ **4. Linked List vs Other Data Structures**
| Feature             | Array | Linked List |
|---------------------|-------|-------------|
| **Random Access**   | âœ… O(1) | âŒ O(n) |
| **Insertion/Deletion (Head)** | âŒ O(n) (shifting) | âœ… O(1) |
| **Insertion/Deletion (Middle)** | âŒ O(n) | âŒ O(n) |
| **Insertion at Tail** | âœ… O(1) (if space available) | âœ… O(1) (if tail pointer) |
| **Memory Overhead** | âœ… Less (no extra pointers) | âŒ More (extra space for pointers) |
| **Cache Performance** | âœ… Better (contiguous memory) | âŒ Poor (non-contiguous) |

---

# **ğŸ”¥ 5. Use Cases of Linked Lists**
âœ… **Dynamic Data Storage** â†’ When memory is fragmented (no contiguous allocation).  
âœ… **Undo/Redo in Applications** â†’ Use a **Doubly Linked List**.  
âœ… **Browser Forward/Backward Navigation** â†’ DLL used for **back & forward** traversal.  
âœ… **Music/Video Playlists** â†’ Circular Linked List for looping playback.  
âœ… **Memory Management (OS Paging, Garbage Collection)** â†’ Linked lists used for managing free memory blocks.  
âœ… **Graph Adjacency List Representation** â†’ Each node stores neighbors dynamically.

---

# **ğŸ”¥ 6. Linked List in DSA Interviews**
ğŸ“Œ **Common Questions:**  
1ï¸âƒ£ Reverse a Linked List  
2ï¸âƒ£ Detect a Cycle in a Linked List (**Floydâ€™s Cycle Algorithm**)  
3ï¸âƒ£ Merge Two Sorted Linked Lists  
4ï¸âƒ£ Find the Middle Element of a Linked List  
5ï¸âƒ£ Remove N-th Node from End of List  

ğŸ“Œ **Key Concepts to Master:**  
- **Recursion** in Linked Lists  
- **Two-pointer techniques (fast & slow pointers)**  
- **Hashing for cycle detection**  

---

# ğŸ¯ **Final Thoughts**
âœ… **When to Use?** â†’ When insertions & deletions matter more than indexing.  
âœ… **When to Avoid?** â†’ When fast random access (O(1)) is required.  
âœ… **Key Strength?** â†’ Flexibility in dynamic memory allocation.  

ğŸ“Œ **DSA Tip:** **Understand linked list variations (Singly, Doubly, Circular)** and when each is useful! ğŸš€  

Would you like a **detailed implementation in Java** as well? ğŸ”¥